import os
import math
import numpy as np
from astropy.io import fits
from corgidrp.nd_filter_calibration import main
from corgidrp.data import Dataset, Image
from corgidrp.mocks import create_default_headers
import astropy.units as u

# From fluxcal.py bright standards
bright_stars = ['109 Vir', 'Vega', 'Eta Uma', 'Lam Lep', 'KSI2 CETI']

# From fluxcal.py dim standards
dim_stars = [
    'TYC 4433-1800-1',
    'TYC 4205-1677-1',
    'TYC 4212-455-1',
    'TYC 4209-1396-1',
    'TYC 4413-304-1',
    'UCAC3 313-62260',
    'BPS BS 17447-0067',
    'TYC 4424-1286-1',
    'GSC 02581-02323',
    'TYC 4207-219-1'
]


def create_flux_image(flux, fwhm, background, nx=1024, ny=1024):
    """
    Create a mock image with a Gaussian source.

    The image is generated by adding a Gaussian source on top of a constant
    background. The Gaussian is centered in the image, and its parameters are
    chosen such that the integrated flux equals the specified flux.

    Parameters:
    flux : float
        The total flux of the Gaussian source (in erg/s/cm^2/Ã… or
        arbitrary units).
    fwhm : float
        The full width at half maximum (FWHM) of the Gaussian source in pixels.
    background : float
        The background level to fill the image.
    nx : int, optional
        The number of pixels along the x-axis. Default is 1024.
    ny : int, optional
        The number of pixels along the y-axis. Default is 1024.

    Returns:
    image : Image
        A `corgidrp.data.Image` object containing the generated image, error,
        and data quality arrays.
    """
    # Create an empty image with the background level
    data = np.full((ny, nx), background, dtype=float)

    # Compute Gaussian parameters
    x0 = nx / 2
    y0 = ny / 2
    sigma = fwhm / (2.0 * math.sqrt(2.0 * math.log(2.0)))

    # Normalize Gaussian so that the integral over all pixels equals
    # the desired flux.
    # The integral of a 2D Gaussian = 2 * pi * sigma^2 * peak, so:
    # peak = flux / (2 * pi * sigma^2)
    peak = flux / (2 * math.pi * sigma**2)

    y_indices, x_indices = np.indices((ny, nx))
    r2 = (x_indices - x0)**2 + (y_indices - y0)**2
    gaussian = peak * np.exp(-r2 / (2 * sigma**2))
    data += gaussian

    # Create error and data quality (DQ) arrays.
    err = np.sqrt(np.abs(data))  # Poisson-like error estimate
    dq = np.zeros((ny, nx), dtype=int)

    pri_hdr, ext_hdr = create_default_headers()
    image = Image(data, pri_hdr=pri_hdr, ext_hdr=ext_hdr, err=err, dq=dq)

    return image


def save_image_to_fits(image, filename):
    """
    Save an Image object to a FITS file following a specific recipe.

    The FITS file will contain a primary HDU with header information
    (but no data) and a secondary ImageHDU that contains the image
    data and its extension header.

    Parameters:
    image : Image
        A `corgidrp.data.Image` object to be saved.
    filename : str
        The output filename (including path) where the FITS file will
        be written.

    Returns:
    None
    """
    primary_hdu = fits.PrimaryHDU(header=image.pri_hdr)
    image_hdu = fits.ImageHDU(data=image.data, header=image.ext_hdr)

    hdul = fits.HDUList([primary_hdu, image_hdu])
    hdul.writeto(filename, overwrite=True)


def mock_dim_dataset_files(output_path):
    """
    Create FITS files for dim star images to serve as calibration references.

    For each dim star name in the global `dim_stars` list, a mock image is
    created, its headers are updated with calibration metadata, and the image
    is saved to a FITS file in the specified output directory.

    Parameters:
    output_path : str
        The directory where the mock dim star FITS files will be saved.

    Returns:
    file_paths : list of str
        A list of file paths to the generated FITS files.
    """
    if not os.path.exists(output_path):
        os.makedirs(output_path, exist_ok=True)

    # Simulate dim stars using a faint flux.
    star_flux = (30.0 * u.STmag).to(u.erg / u.s / u.cm**2 / u.AA)
    fwhm = 3
    background = star_flux.value / 20

    file_paths = []
    for star_name in dim_stars:
        flux_image = create_flux_image(star_flux.value, fwhm, background)
        # Update headers with calibration metadata.
        flux_image.ext_hdr['TARGET'] = star_name
        flux_image.ext_hdr['CFAMNAME'] = '3C'  # Must match a known filter.
        flux_image.ext_hdr['FPAM_H'] = 3.0
        flux_image.ext_hdr['FPAM_V'] = 2.5
        flux_image.ext_hdr['EXPTIME'] = 10.0  # Example exposure time.

        # Remove spaces from the star name for filename safety.
        safe_star_name = star_name.replace(' ', '_')
        filename = os.path.join(output_path,
                                f"mock_dim_dataset_{safe_star_name}.fits")
        save_image_to_fits(flux_image, filename)
        file_paths.append(str(filename))

    return file_paths


def mock_bright_dataset_files(output_path):
    """
    Create FITS files for bright star images arranged in a raster pattern.

    For the first four bright stars in the global `bright_stars` list, a
    3x3 raster (total of 9 images per star) is created with slight positional
    offsets. Each image is saved as a FITS file with updated calibration
    headers.

    Parameters:
    output_path : str
        The directory where the mock bright star FITS files will be saved.

    Returns:
    file_paths : list of str
        A list of file paths to the generated FITS files.
    """
    if not os.path.exists(output_path):
        os.makedirs(output_path, exist_ok=True)

    # Simulate bright stars using a relatively high flux.
    bright_star_flux = (20.0 * u.STmag).to(u.erg / u.s / u.cm**2 / u.AA)
    fwhm = 3
    background = bright_star_flux.value / 20

    # Pick the first 4 bright standards.
    selected_bright_stars = bright_stars[:4]
    x_offsets = [-10, 0, 10]
    y_offsets = [-10, 0, 10]

    file_paths = []
    for star_name in selected_bright_stars:
        index = 1
        for dy in y_offsets:
            for dx in x_offsets:
                # Multiply flux by 10 for bright stars.
                flux_image = create_flux_image(bright_star_flux.value * 10,
                                               fwhm, background)
                flux_image.ext_hdr['TARGET'] = star_name
                flux_image.ext_hdr['CFAMNAME'] = '3C'
                flux_image.ext_hdr['FPAM_H'] = 3.0
                flux_image.ext_hdr['FPAM_V'] = 2.5
                flux_image.ext_hdr['FSM_X'] = dx
                flux_image.ext_hdr['FSM_Y'] = dy
                # Shorter exposure for bright stars.
                flux_image.ext_hdr['EXPTIME'] = 5.0

                safe_star_name = star_name.replace(' ', '_')
                filename = os.path.join(
                    output_path,
                    f"mock_bright_dataset_{safe_star_name}_{index}.fits")
                save_image_to_fits(flux_image, filename)
                file_paths.append(str(filename))
                index += 1

    return file_paths


if __name__ == "__main__":
    print('Running test_nd_filter_calibration')

    # User paths for dim and bright mock datasets and output.
    dim_data_path = (
        '/Users/jmilton/Github/corgidrp/corgidrp/data/nd_filter_mocks_dim'
    )
    bright_data_path = (
        '/Users/jmilton/Github/corgidrp/corgidrp/data/nd_filter_mocks_bright'
    )
    output_path = (
        '/Users/jmilton/Github/corgidrp/tests/e2e_tests/nd_filter_output'
    )

    dim_files = mock_dim_dataset_files(dim_data_path)
    bright_files = mock_bright_dataset_files(bright_data_path)

    input_dim_dataset = Dataset(dim_files)
    input_bright_dataset = Dataset(bright_files)

    # Run the main ND filter calibration routine.
    main(input_dim_dataset, input_bright_dataset, output_path)
