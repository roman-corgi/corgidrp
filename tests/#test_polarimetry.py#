import numpy as np
import pytest
import corgidrp.mocks as mocks
import corgidrp.l2b_to_l3 as l2b_to_l3
import corgidrp.l4_to_tda as l4_to_tda
import corgidrp.data as data

def test_image_splitting():
    """
    Create mock L2b polarimetric images, check that it is split correctly
    """

    # test autocropping WFOV
    ## generate mock data
    image_WP1_wfov = mocks.create_mock_l2b_polarimetric_image(dpamname='POL0', observing_mode='WFOV', left_image_value=1, right_image_value=2)
    image_WP2_wfov = mocks.create_mock_l2b_polarimetric_image(dpamname='POL45', observing_mode='WFOV', left_image_value=1, right_image_value=2)
    input_dataset_wfov = data.Dataset([image_WP1_wfov, image_WP2_wfov])

    ## leave image_size parameter blank so the function automatically determines size
    output_dataset_autocrop_wfov = l2b_to_l3.split_image_by_polarization_state(input_dataset_wfov)
    ## create what the expected output data should look like
    radius_wfov = int(round((20.1 * ((0.8255 * 1e-6) / 2.363114) * 206265) / 0.0218))
    padding = 5
    img_size_wfov = 2 * (radius_wfov + padding)
    expected_output_autocrop_wfov = np.zeros(shape=(2, img_size_wfov, img_size_wfov))
    ## fill in expected values
    img_center_wfov = radius_wfov + padding
    y_wfov, x_wfov = np.indices([img_size_wfov, img_size_wfov])
    expected_output_autocrop_wfov[0, ((x_wfov-img_center_wfov)**2) + ((y_wfov-img_center_wfov)**2) <= radius_wfov**2] = 1
    expected_output_autocrop_wfov[1, ((x_wfov-img_center_wfov)**2) + ((y_wfov-img_center_wfov)**2) <= radius_wfov**2] = 2

    ## check that actual output is as expected
    assert output_dataset_autocrop_wfov.frames[0].data == pytest.approx(expected_output_autocrop_wfov)
    assert output_dataset_autocrop_wfov.frames[1].data == pytest.approx(expected_output_autocrop_wfov)

    # test autocropping NFOV
    ## generate mock data
    image_WP1_nfov = mocks.create_mock_l2b_polarimetric_image(dpamname='POL0', observing_mode='NFOV', left_image_value=1, right_image_value=2)
    image_WP2_nfov = mocks.create_mock_l2b_polarimetric_image(dpamname='POL45', observing_mode='NFOV', left_image_value=1, right_image_value=2)
    input_dataset_nfov = data.Dataset([image_WP1_nfov, image_WP2_nfov])

    ## leave image_size parameter blank so the function automatically determines size
    output_dataset_autocrop_nfov = l2b_to_l3.split_image_by_polarization_state(input_dataset_nfov)
    ## create what the expected output data should look like
    radius_nfov = int(round((9.7 * ((0.5738 * 1e-6) / 2.363114) * 206265) / 0.0218))
    img_size_nfov = 2 * (radius_nfov + padding)
    expected_output_autocrop_nfov = np.zeros(shape=(2, img_size_nfov, img_size_nfov))
    ## fill in expected values
    img_center_nfov = radius_nfov + padding
    y_nfov, x_nfov = np.indices([img_size_nfov, img_size_nfov])
    expected_output_autocrop_nfov[0, ((x_nfov-img_center_nfov)**2) + ((y_nfov-img_center_nfov)**2) <= radius_nfov**2] = 1
    expected_output_autocrop_nfov[1, ((x_nfov-img_center_nfov)**2) + ((y_nfov-img_center_nfov)**2) <= radius_nfov**2] = 2

    ## check that actual output is as expected
    assert output_dataset_autocrop_nfov.frames[0].data == pytest.approx(expected_output_autocrop_nfov)
    assert output_dataset_autocrop_nfov.frames[1].data == pytest.approx(expected_output_autocrop_nfov)

    # test cropping with alignment angle input
    image_WP1_custom_angle = mocks.create_mock_l2b_polarimetric_image(dpamname='POL0', observing_mode='NFOV', left_image_value=1, right_image_value=2, alignment_angle=5)
    image_WP2_custom_angle = mocks.create_mock_l2b_polarimetric_image(dpamname='POL45', observing_mode='NFOV', left_image_value=1, right_image_value=2, alignment_angle=40)
    input_dataset_custom_angle = data.Dataset([image_WP1_custom_angle, image_WP2_custom_angle])
    output_dataset_custom_angle = l2b_to_l3.split_image_by_polarization_state(input_dataset_custom_angle, alignment_angle_WP1=5, alignment_angle_WP2=40)

    ## check that actual output is as expected, should still be the same as the previous test since mock data is in NFOV mode
    assert output_dataset_custom_angle.frames[0].data == pytest.approx(expected_output_autocrop_nfov)
    assert output_dataset_custom_angle.frames[1].data == pytest.approx(expected_output_autocrop_nfov)

    # test NaN pixels
    img_size = 400
    output_dataset_custom_crop = l2b_to_l3.split_image_by_polarization_state(input_dataset_wfov, image_size=img_size)
    ## create what the expected output data should look like
    expected_output_WP1 = np.zeros(shape=(2, img_size, img_size))
    expected_output_WP2 = np.zeros(shape=(2, img_size, img_size))
    img_center = 200
    y, x = np.indices([img_size, img_size])
    expected_output_WP1[0, ((x-img_center)**2) + ((y-img_center)**2) <= radius_wfov**2] = 1
    expected_output_WP1[1, ((x-img_center)**2) + ((y-img_center)**2) <= radius_wfov**2] = 2
    expected_output_WP2[0, ((x-img_center)**2) + ((y-img_center)**2) <= radius_wfov**2] = 1
    expected_output_WP2[1, ((x-img_center)**2) + ((y-img_center)**2) <= radius_wfov**2] = 2
    expected_output_WP1[0, x >= 372] = np.nan
    expected_output_WP1[1, x <= 28] = np.nan
    expected_output_WP2[0, y <= x - 244] = np.nan
    expected_output_WP2[1, y >= x + 244] = np.nan
    ## check that the actual output is as expected
    assert output_dataset_custom_crop.frames[0].data == pytest.approx(expected_output_WP1, nan_ok=True)
    assert output_dataset_custom_crop.frames[1].data == pytest.approx(expected_output_WP2, nan_ok=True)

    # test that an error is raised if we set the image size too big
    with pytest.raises(ValueError):
        invalid_output = l2b_to_l3.split_image_by_polarization_state(input_dataset_wfov, image_size=682)


def create_mock_l2b_polarimetric_image(image_center=(512, 512), dpamname='POL0', observing_mode='NFOV',
                                       left_image_value=1, right_image_value=1, alignment_angle=None):
    """
    Creates mock L2b polarimetric data with two polarized images placed on the larger
    detector frame. Image size and placement depends on the wollaston used and the observing mode.

    Args:
        image_center (optional, tuple(int, int)): pixel location of where the two images are centered on the detector
        dpamname (optional, string): name of the wollaston prism used, accepted values are 'POL0' and 'POL45'
        observing_mode (optional, string): observing mode of the coronagraph
        left_image_value (optional, int): value to fill inside the radius of the left image, corresponding to 0 or 45 degree polarization
        right_image_value (optional, int): value to fill inside the radius of the right image, corresponding to 90 or 135 degree polarization
        alignment_angle (optional, float): the angle in degrees of how the two polarized images are aligned with respect to the horizontal,
            defaults to 0 for WP1 and 45 for WP2
    
    Returns:
        corgidrp.data.Image: The simulated L2b polarimetric image
    """
    assert dpamname in ['POL0', 'POL45'], \
        "Invalid prism selected, must be 'POL0' or 'POL45'"
    
    # create initial blank frame
    image_data = np.zeros(shape=(1024, 1024))

    image_separation_arcsec = 7.5

    #determine radius of the images
    if observing_mode == 'NFOV':
        cfamname = '1F'
        radius = int(round((9.7 * ((0.5738 * 1e-6) / 2.363114) * 206265) / 0.0218))
    elif observing_mode == 'WFOV':
        cfamname = '4F'
        radius = int(round((20.1 * ((0.8255 * 1e-6) / 2.363114) * 206265) / 0.0218))
    else:
        cfamname = '1F'
        radius = int(round(1.9 / 0.0218))
    
    #determine the center of the two images
    if alignment_angle is None:
        if dpamname == 'POL0':
            alignment_angle = 0
        else:
            alignment_angle = 45
    angle_rad = alignment_angle * (np.pi / 180)
    displacement_x = int(round((7.5 * np.cos(angle_rad)) / (2 * 0.0218)))
    displacement_y = int(round((7.5 * np.sin(angle_rad)) / (2 * 0.0218)))
    center_left = (image_center[0] - displacement_x, image_center[1] + displacement_y)
    center_right = (image_center[0] + displacement_x, image_center[1] - displacement_y)

    #fill the location where the images are with 1s
    y, x = np.indices([1024, 1024])
    image_data[((x - center_left[0])**2) + ((y - center_left[1])**2) <= radius**2] = left_image_value
    image_data[((x - center_right[0])**2) + ((y - center_right[1])**2) <= radius**2] = right_image_value
    
    #create L2b headers
    prihdr, exthdr, errhdr, dqhdr, biashdr = create_default_L2b_headers()
    #define necessary header keywords
    exthdr['CFAMNAME'] = cfamname
    exthdr['DPAMNAME'] = dpamname
    exthdr['LSAMNAME'] = observing_mode
    image = data.Image(image_data, pri_hdr=prihdr, ext_hdr=exthdr)

    return image
         
def test_calc_pol_p_and_pa_image(p_input=0.1, theta_input=10.0):
    """Test calc_pol_p_and_pa_image using a mock Stokes cube."""

    # Generate mock Stokes cube
    Image_polmock = mocks.create_mock_stokes_image(
        badpixel_fraction=0.,
        p=p_input,
        theta_deg=theta_input,
        level='l4'
    )

    # Compute polarization products
    image_pol = l4_to_tda.calc_pol_p_and_pa_image(Image_polmock)

    p_map = image_pol.data[1]       # fractional polarization
    evpa_map = image_pol.data[2]    # EVPA

    assert p_map == pytest.approx(p_input)
    assert evpa_map == pytest.approx(theta_input)

    
if __name__ == "__main__":
    test_image_splitting()
    test_calc_pol_p_and_pa_image()
