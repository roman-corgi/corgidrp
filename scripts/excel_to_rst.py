#!/usr/bin/env python3
"""
Convert Excel documentation file (generated by zz_dataformat_e2e.py) to RST format.
Put rst in docs/source/data_formats/.

Usage:
    python excel_to_rst.py <excel_file> [--datatype DATATYPE] [--output OUTPUT]
    
Example:
    python excel_to_rst.py l2a_documentation.xlsx --datatype L2a
    python excel_to_rst.py flt_cal_documentation.xlsx --output flat.rst
"""

import os
import sys
import argparse
import pandas as pd

sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

def read_excel_to_rst(excel_path, datatype_name=None, output_path=None):
    """Convert Excel file to RST documentation."""
    
    if not os.path.exists(excel_path):
        raise FileNotFoundError(f"Excel file not found: {excel_path}")
    
    excel_file = pd.ExcelFile(excel_path)
    
    if 'Extensions_Overview' not in excel_file.sheet_names:
        raise ValueError("Excel file missing 'Extensions_Overview' sheet")
    
    extensions_df = pd.read_excel(excel_path, sheet_name='Extensions_Overview')
    
    # Figure out datatype name from filename if not provided
    if datatype_name is None:
        base = os.path.splitext(os.path.basename(excel_path))[0]
        datatype_name = base.replace('_documentation', '').replace('_cal', '').title()
    
    hdu_table = generate_hdu_structure_from_df(extensions_df)
    
    # Build header tables for each HDU
    header_tables = []
    for idx, row in extensions_df.iterrows():
        hdu_index = int(row['Index'])
        header_table = find_and_generate_header(excel_file, excel_path, extensions_df, hdu_index, row)
        if header_table:
            header_tables.append(header_table)
    
    all_header_tables = "\n".join(header_tables)
    datatype_lower = datatype_name.lower().replace(' ', '_')
    
    # Build RST content
    template = """.. _{0}-label:

{1} Data Product
========================================


FITS HDU Structure
------------------

{2}

Header
------

{3}
"""
    
    rst_content = template.format(datatype_lower, datatype_name, hdu_table, all_header_tables)
    
    # Figure out where to save the file
    if output_path is None:
        script_dir = os.path.dirname(os.path.abspath(__file__))
        repo_root = os.path.dirname(script_dir)
        docs_dir = os.path.join(repo_root, 'docs', 'source', 'data_formats')
        rst_filename = datatype_lower.replace('_', '').replace('-', '').lower()
        if rst_filename.endswith('cal'):
            rst_filename = rst_filename[:-3] + '.rst'
        else:
            rst_filename += '.rst'
        output_path = os.path.join(docs_dir, rst_filename)
    else:
        # If just a filename, use default docs directory
        if not os.path.dirname(output_path):
            script_dir = os.path.dirname(os.path.abspath(__file__))
            repo_root = os.path.dirname(script_dir)
            docs_dir = os.path.join(repo_root, 'docs', 'source', 'data_formats')
            output_path = os.path.join(docs_dir, output_path)
    
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    
    with open(output_path, 'w') as f:
        f.write(rst_content)
    
    print(f"RST file generated: {output_path}")
    return output_path


def find_and_generate_header(excel_file, excel_path, extensions_df, hdu_index, row):
    """Find the right header sheet and generate RST table for it."""
    
    # Figure out what to call this HDU
    if hdu_index == 0:
        hdu_name = "Primary"
        sheet_name = "Primary_Header"
    elif hdu_index == 1:
        hdu_name = "Image"
        ext_name = row.get('Extension Name', None)
        # Try to find sheet by extension name, or fall back to Image_Header/Extension_1_Header
        if ext_name and pd.notna(ext_name) and str(ext_name).strip():
            sheet_name = f"{str(ext_name).strip()}_Header"
        elif "Image_Header" in excel_file.sheet_names:
            sheet_name = "Image_Header"
        elif "Extension_1_Header" in excel_file.sheet_names:
            sheet_name = "Extension_1_Header"
        else:
            sheet_name = None
    else:
        ext_name = row.get('Extension Name', f'Extension {hdu_index}')
        hdu_name = ext_name
        sheet_name = f"{hdu_name}_Header"
    
    # Try to read the header sheet
    header_df = None
    if sheet_name and sheet_name in excel_file.sheet_names:
        header_df = pd.read_excel(excel_path, sheet_name=sheet_name)
    else:
        # Fallback: search for any header sheet that matches
        for sheet in excel_file.sheet_names:
            if "Header" not in sheet:
                continue
            if hdu_index == 0 and "Primary" in sheet:
                header_df = pd.read_excel(excel_path, sheet_name=sheet)
                break
            elif hdu_index == 1:
                # For HDU 1, accept any header sheet that's not Primary and doesn't belong to another HDU
                if "Primary" in sheet:
                    continue
                # Skip if this sheet belongs to another HDU we know about
                if sheet_belongs_to_other_hdu(sheet, extensions_df, hdu_index):
                    continue
                header_df = pd.read_excel(excel_path, sheet_name=sheet)
                break
            elif hdu_index > 1:
                # Match by HDU index or extension name
                if (f"HDU_{hdu_index}" in sheet or f"Extension_{hdu_index}" in sheet or 
                    (hdu_name and hdu_name in sheet)):
                    header_df = pd.read_excel(excel_path, sheet_name=sheet)
                    break
    
    if header_df is not None and len(header_df) > 0:
        return generate_header_table_from_df(header_df, hdu_index, hdu_name)
    else:
        print(f"Warning: No header sheet found for HDU {hdu_index} ({hdu_name}). Available sheets: {excel_file.sheet_names}")
        return None


def sheet_belongs_to_other_hdu(sheet, extensions_df, hdu_index):
    """Check if a sheet name matches another HDU from the extensions overview."""
    sheet_lower = sheet.lower()
    known_extensions = ['err', 'dq', 'error', 'data quality', 'gauss_par', 'flux_prof']
    
    # Check against other HDUs
    for other_idx, other_row in extensions_df.iterrows():
        if int(other_row['Index']) == hdu_index:
            continue
        other_ext_name = other_row.get('Extension Name', None)
        if other_ext_name and pd.notna(other_ext_name):
            other_ext_str = str(other_ext_name).strip().lower()
            if other_ext_str in sheet_lower:
                return True
    
    # Check against known extension patterns
    sheet_base = sheet_lower.replace('_header', '').replace('header', '').strip()
    for known_ext in known_extensions:
        if known_ext in sheet_lower or known_ext in sheet_base:
            return True
    
    return False


def generate_hdu_structure_from_df(extensions_df):
    """Build RST table showing HDU structure."""
    
    table = '''
+-------+------------------+----------+----------------------+
| Index | Name             | Datatype | Array Size           |
+=======+==================+==========+======================+
'''
    
    row_template = "| {0:<5} | {1:<16} | {2:<8} | {3:<20} |"
    row_delimiter = "+-------+------------------+----------+----------------------+"
    
    for idx, row in extensions_df.iterrows():
        hdu_index = int(row['Index'])
        
        if hdu_index == 0:
            hdu_name = "Primary"
        elif hdu_index == 1:
            hdu_name = "Image"
        else:
            hdu_name = row.get('Extension Name', f'Extension {hdu_index}')
        
        datatype = str(row.get('Data Type', 'None'))
        arr_size = str(row.get('Array Size', '0'))
        
        table += row_template.format(hdu_index, hdu_name, datatype, arr_size)
        table += "\n" + row_delimiter + "\n"
    
    return table


def generate_header_table_from_df(header_df, hdu_index, hdu_name):
    """Build RST table for header keywords."""
    
    title = f"{hdu_name} Header (HDU {hdu_index})"
    title_delim = "=" * len(title)
    
    table = f"""{title}
{title_delim}

+------------+------------+--------------------------------+----------------------------------------------------+
| Keyword    | Datatype   | Example Value                  | Description                                        |
+============+============+================================+====================================================+
"""
    
    row_template = "| {0:<10} | {1:<10} | {2:<30} | {3:<50} |"
    row_delimiter = "+------------+------------+--------------------------------+----------------------------------------------------+"
    
    # Find the right columns (Excel sometimes has slightly different names?)
    keyword_col = find_column(header_df, ['keyword'])
    dtype_col = find_column(header_df, ['datatype', 'data type'])
    value_col = find_column(header_df, ['value', 'example'])
    desc_col = find_column(header_df, ['description'])
    
    if keyword_col is None:
        raise ValueError(f"Could not find 'Keyword' column in header sheet")
    
    history_done = False
    comment_done = False
    file_done = False
    
    for idx, row in header_df.iterrows():
        keyword = str(row[keyword_col]).strip()
        
        if not keyword or keyword == 'nan':
            continue
        
        # Handle special keywords that repeat
        if keyword == "HISTORY":
            if history_done:
                continue
            history_done = True
            datatype = "str"
        elif keyword == "COMMENT":
            if comment_done:
                continue
            comment_done = True
            datatype = "str"
        elif keyword.startswith("FILE") and len(keyword) > 4 and keyword[4:].isdigit():
            if file_done:
                continue
            file_done = True
            datatype = get_datatype(row, dtype_col, value_col) or "str"
            description = "File name for the n-th science file used"
        else:
            datatype = get_datatype(row, dtype_col, value_col) or "unknown"
        
        # Get example value
        if value_col and value_col in row and pd.notna(row[value_col]):
            example_value = str(row[value_col]).replace("\n", " ")
            if len(example_value) > 30:
                example_value = example_value[:27] + "..."
        else:
            example_value = ""
        
        # Get description
        if desc_col and desc_col in row and pd.notna(row[desc_col]):
            description = str(row[desc_col]).strip()
        elif keyword.startswith("FILE") and len(keyword) > 4 and keyword[4:].isdigit():
            description = "File name for the n-th science file used"
        else:
            description = ""
        
        if len(description) > 50:
            description = description[:47] + "..."
        
        table += row_template.format(keyword, datatype, example_value, description)
        table += "\n" + row_delimiter + "\n"
    
    return table


def find_column(df, possible_names):
    """Find a column by name, trying exact match then fuzzy match."""
    for col in df.columns:
        if col in possible_names:
            return col
        col_normalized = col.lower().replace(' ', '').replace('_', '').replace('-', '')
        for name in possible_names:
            if name in col_normalized:
                return col
    return None


def get_datatype(row, dtype_col, value_col):
    """Get and normalize datatype from row."""
    if dtype_col and dtype_col in row and pd.notna(row[dtype_col]):
        dtype = str(row[dtype_col]).strip().lower()
        # Normalize to Python types
        if dtype in ['int', 'int64', 'int32', 'integer']:
            return "int"
        elif dtype in ['float', 'float64', 'float32']:
            return "float"
        elif dtype in ['bool', 'boolean']:
            return "bool"
        elif dtype in ['str', 'string']:
            return "str"
        elif dtype in ['nonetype', 'none']:
            return "NoneType"
        elif dtype == 'other':
            # Try to infer from value
            if value_col and value_col in row:
                value = row[value_col]
                if pd.isna(value) or value is None or str(value).strip() in ['', 'None', 'nan', 'NaN']:
                    return "NoneType"
            return "other"
    return None


def main():
    parser = argparse.ArgumentParser(
        description="Convert Excel documentation file to RST format",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )
    
    parser.add_argument('excel_file', help='Path to the Excel documentation file')
    parser.add_argument('--datatype', dest='datatype_name', help='Datatype name (e.g., "L2a"). Auto-detected from filename if not provided.')
    parser.add_argument('--output', '-o', dest='output_path', help='Output RST file path. Defaults to docs/source/data_formats/')
    
    args = parser.parse_args()
    
    try:
        output_path = read_excel_to_rst(args.excel_file, args.datatype_name, args.output_path)
        print(f"Success! RST file saved to: {output_path}")
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()